import abc
import re
import numpy as np
import warnings
from msmbuilder import Serializer
try: from msmbuilder import metric_LPRMSD as lprmsd # This is down here because metric_LPRMSD imports this file, and so it is a bad recursion issue. This should be fixed by combining LP's metric into this file...
except: lprmsd = None
from msmbuilder.metrics import AbstractDistanceMetric, Vectorized
from msmbuilder import metrics

class RedDimPNorm(Vectorized,AbstractDistanceMetric):
    """
    This is a class for using a reduced dimensionality representation for the trajectory data. A transformation matrix must be generated by some other method
    """

    class PCAObj:
        def __init__( self, pca_fn):
            data_dict = Serializer.LoadFromHDF( pca_fn )
            self.vecs = np.array( data_dict['vecs'] )
            self.vals = np.array( data_dict['vals'].real.astype(float) ) # These should be real already but have 1E-16j attached to them
            dec_ind = np.argsort( self.vals )[::-1]
            
            self.vecs = np.array( self.vecs[:,dec_ind] )
            self.vals = np.array( self.vals[dec_ind] )
 
            self.red_vecs = self.vecs # These containers will hold the reduced version of the matrix
            self.red_vals = self.vals

        def reduce( self, abs_min=None, num_vecs=None, expl_var=None ):
            
            if num_vecs != None:
                self.red_vecs = self.vecs[:,:num_vecs]
                self.red_vals = self.vals[:num_vecs]
            elif expl_var != None:
                expl_var *= self.vals.sum() # Multiply by total variance to convert from the relative input to the absolute variance scale
                N = np.where( np.cumsum( self.vals ) > expl_var )[0][0] # Get the first index that the total variance is greater than the input var
                self.red_vecs = self.vecs[:,:N]
                self.red_vals = self.vals[:N]
            elif abs_min != None:
                keep_ind = np.where( self.vals >= abs_min )[0] # For whatever reason, passing a tuple to the second axis in an nd.array adds an extra dimension
                self.red_vecs = self.vecs[:,keep_ind]
                self.red_vals = self.vals[keep_ind]
            
            print "Kept %d out of %d total vectors" % ( self.red_vals.shape[0], self.vals.shape[0] )
 
            return

        def execute( self, ptraj ):
            return np.dot( ptraj.conj(), self.red_vecs )           

    def __init__(self,pcaObjFN,pdbFN=None,prep_with=None,abs_min=None,num_vecs=None, expl_var=None, metric='euclidean',p=2):
        """Inputs:
        1) pcaObj - An mdp.PCANode object that has been trained on the data set already.
        2) pdbFN [ None ] - If using positions, then this must be specified. Otherwise it should be none.
        3) prep_with [ None ] - If using positions, this should be none. Otherwise it should be an instance of another metric.
           The prepare_trajectory method of that metric will be used to calculate a certain quantity, e.g. dihedrals, or contacts
        4) metric [ 'euclidean' ] - Should be a valid entry for the Vectorized class (see metrics.Vectorized)
        5) p [ 2 ] - Exponent for the p-norm
        """
        if pcaObjFN[-3:] == 'npy':
            self.pca = np.load(pcaObjFN)
        else:
            self.pca = self.PCAObj( pcaObjFN )
            if num_vecs:
                self.num_vecs = int( num_vecs )
            else:
                self.num_vecs = None
 
            if expl_var:
                self.expl_var = float( expl_var )
            else:
                self.expl_var = None

            if abs_min:
                self.abs_min = float( abs_min )
            else:
                self.abs_min = None

            self.pca.reduce( num_vecs = self.num_vecs, expl_var = self.expl_var, abs_min = self.abs_min )
 
        self.lprmsd = lprmsd.LPRMSD()

        if pdbFN:
            self.align2pdb = self.lprmsd.prepare_trajectory( lprmsd.LPTraj.LoadFromPDB( pdbFN ) )
            self.use_positions = True
        else:
            self.use_positions = False
            if prep_with:
                self.prep_with = prep_with
            else:
                raise Exception('Must provide one of prep_with or pdbFN')
        if metric.lower() == 'weight_prep_with':
            metric = 'euclidean'
            self.weighted_prep_with = True
        else:
            self.weighted_prep_with = False
        super(RedDimPNorm,self).__init__(metric,p)

    def prepare_trajectory(self,trajectory):

        if self.use_positions:
            sol = self.lprmsd.one_to_all_aligned( self.align2pdb, self.lprmsd.prepare_trajectory( trajectory ),0 ) # align the trajectory to the pdb
            n0,n1,n2 = sol[1].shape
            trajectory = self.pca.execute( sol[1].reshape( n0, n1*n2 ) )
        else:
            trajectory = self.prep_with.prepare_trajectory( trajectory )
            if len(trajectory.shape) == 3:
                n0,n1,n2 = trajectory.shape
                trajectory = self.pca.execute( trajectory.reshape( n0, n1*n2 ) )
            else:
                trajectory = self.pca.execute( np.array([ frame.flatten() for frame in trajectory ]) ) 
            # The prepared trajectory should be iterable. ONLY RMSD messes this up. If this isn't the case, it's likely the pca.execute will break anyway.

#        trajectory = np.concatenate( (trajectory.real,trajectory.imag), axis=1 ).copy() # copy to make it contiguous memory

        return trajectory

