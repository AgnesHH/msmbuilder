"""
To USE this code, from a client perspective, all you want to do is

>> from metrics import RMSD, Dihedral, Contact

Nothing else in this modules' namespace will be useful to you as a client.

and then for example

>> rmsdtraj1 = RMSD.prepare_trajectory(traj, atomindices)
>> RMSD.one_to_all(rmsdtraj1, rmsdtraj1, 0)
>> dihedraltraj1 = Dihedral.prepare_trajectory(traj)
>> Dihedral.one_to_all(dihedraltraj1, dihedraltraj1, 0)

this would compute the distances from frame 0 to all other frames under both
the rmsd metric and dihedral metric. There are a lot more options and ways you can
calcuate distances (euclidean distance vs. cityblock vs pnorm, etc etc.) and select
the frames you care about (one_to_all(), one_to_many(), many_to_many(), all_to_all(), etc).

NOTE: Because the code leverages inheritance, if you just casually browse the code
for Dihedral for example, you ARE NOT going to see all methods that the class
actually implements. I would browsing the docstrings in ipython.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=

To DEVELOP on top of this code, just implement some classes that inherit from
either AbstractDistanceMetric or Vectorized. In particular, if you inherit
from Vectorized, you get a fully functional DistanceMetric class almost for
free. All you have to do is define a prepare_trajectory() fuction.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=

This should be an (almost) drop in replacement for
msmbuilder's DistanceMetic.py, but I think it is much
easier to extend.

Changes (combared to msmbuilder.DistanceMetric):
(1) Moved all the RMSD specific code in DistanceMetric.py
    into the RMSD class. (TheoData stuff). I also
    eliminated the TheoData getters and setters because this is python and
    everything is public / we're all consenting adults.
(2) All distance metrics now inherit from the abstract base
    class AbstractDistanceMetric, and define (at minimum) the
    methods prepare_trajectory(), one_to_many() and one_to_all()
(3) Dihedral and Contact implement the same interface
    as RMSD
(4) Dihedral and Contact share code by subclassing
    Vectorized, which lets you use any distance metric on vectors
    (euclidean, manhattan, chebychev, pnorm, etc) that you like. All
    that Dihedral and Contact have to actually implement
    themselves is their prepare_trajectory function which processes the
    trajectory into a bunch of vectors.
(5) So, anyone can really easily make a new Vectorized. All you have to
    do is put the code that prepares the vectors into a function called
    prepare_trajectory and put that into a class that subclasses Vectorized.
    Furthermore, if you would like to set the default metric used to not be
    euclidean (for instance in Contact since the prepared_trajectories are
    boolean vectors, you dont want euclidean to be the default), you set the
    the class variable 'default_scipy_metric' to be whatever you like.
    Thats all there is to it!
    
    
#=#=#=#+#+#+#+#+#+#+#+#+#+#+#+#+#
ALSO:
    This should be documented better somewhere, because it will cause cryptic
    errors if you don't do it. Whatever data structure you return from prepare_trajectory()
    needs to support slice sytax. If you return an array or something, then this is
    no problem, but if you create your own object to hold the data that prepare_trajectory()
    returns, you need to add a __getitem__(), __setitem__() and __len__() methods. See the
    RMSD.TheoData object below. Also, if you're not familiar with this side of python,
    these docs (http://docs.python.org/reference/datamodel.html#emulating-container-types)
    are pretty good. Only __getitem__, __setitem__ and __len__ are necessary.
#=#=#=#+#+#+#+#+#+#+#+#+#+#+#+#+#
"""


import abc
import re
import numpy as np
import warnings
from Emsmbuilder import metric_LPRMSD as lprmsd # This is down here because metric_LPRMSD imports this file, and so it is a bad recursion issue. This should be fixed by combining LP's metric into this file...
from Emsmbuilder.metrics import AbstractDistanceMetric, Vectorized

class RedDimPNorm(Vectorized,AbstractDistanceMetric):
    """
    This is a class for using a reduced dimensionality representation for the trajectory data. A transformation matrix must be generated by some other method
    """

    def __init__(self,pcaObj,pdbFN,metric='euclidean',p=2):
        self.pca = np.load(pcaObj)
        self.lprmsd = lprmsd.LPRMSD()
        self.align2pdb = self.lprmsd.prepare_trajectory( lprmsd.LPTraj.LoadFromPDB( pdbFN ) )
        super(RedDimPNorm,self).__init__(metric,p)

    def prepare_trajectory(self,trajectory):
        sol = self.lprmsd.one_to_all_aligned( self.align2pdb, self.lprmsd.prepare_trajectory( trajectory ),0 ) # align the trajectory to the pdb
        #trajectory = np.array([ np.dot( frame.flatten(), self.projMat ) for frame in sol[1] ]) # Convert the data to the low-D space
        trajectory = self.pca.execute( np.array([ frame.flatten() for frame in sol[1] ]) )

        return trajectory

